<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>License Signer Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        display: flex;
      }
      section {
        padding: 1em;
      }
      form {
        display: block;
        width: 30em;
        display: flex;
        flex-direction: column;
      }
      .r {
        display: flex;
        flex-direction: column;
      }
      label {
        font-weight: bold;
        display: block;
      }
      .buttons {
        margin: 1em;
        text-align: center;
      }
      button {
        padding: 0.5em;
        min-width: 10em;
      }
    </style>
  </head>
  <body>
    <section>
      <h1>Text Signer</h1>
      <form id="sign">
        <div class="r">
          <label for="key">Private Key</label>
          <textarea id="key" name="key" required rows="10"></textarea>
        </div>
        <div class="r">
          <label for="payload">Payload</label>
          <input id="payload" name="payload" required />
        </div>
        <div class="buttons">
          <button type="submit">Sign</button>
          <button type="reset">Reset</button>
        </div>
        <div class="r">
          <label for="o">Signed</label>
          <textarea id="o" readonly rows="2"></textarea>
        </div>
      </form>
    </section>
    <section>
      <h1>Text Verifier</h1>
      <form id="verify">
        <div class="r">
          <label for="pkey">Public Key</label>
          <textarea id="pkey" name="key" required rows="10"></textarea>
        </div>
        <div class="r">
          <label for="code">Code</label>
          <input id="code" name="code" required />
        </div>
        <div class="buttons">
          <button type="submit">Verify</button>
          <button type="reset">Reset</button>
        </div>
        <div class="r">
          <label for="ov">Output</label>
          <textarea id="ov" readonly rows="2"></textarea>
        </div>
      </form>
    </section>
    <section>
      <h1>Key Generator</h1>
      <form id="keys">
        <div class="buttons">
          <button type="submit">Generate</button>
        </div>
        <div class="r">
          <label for="private">Private Key</label>
          <textarea id="private" readonly rows="10"></textarea>
        </div>
        <div class="r">
          <label for="public">Public Key</label>
          <textarea id="public" readonly rows="10"></textarea>
        </div>
      </form>
    </section>
    <script type="module">
      export function generateKeyPair(algorithm) {
        if (!self.crypto || !self.crypto.subtle) {
          return () => Promise.resolve([null, null]);
        }
        return self.crypto.subtle
          .generateKey(algorithm, true, ["sign", "verify"])
          .then((key) => {
            const pair = key;
            return Promise.all([
              self.crypto.subtle.exportKey("jwk", pair.privateKey),
              self.crypto.subtle.exportKey("jwk", pair.publicKey),
            ]);
          });
      }
      export function decodeAndVerifySignature(
        key,
        importAlgorithm,
        verifyAlgorithm,
      ) {
        if (!self.crypto || !self.crypto.subtle) {
          return () => Promise.resolve(null);
        }
        const keyPromise = self.crypto.subtle.importKey(
          "jwk",
          key,
          importAlgorithm,
          false,
          ["verify"],
        );

        return (code) => {
          try {
            if (!code.includes("$")) {
              return Promise.resolve(null);
            }
            const payload = atob(code.slice(0, code.indexOf("$")));
            const sig = new Uint8Array(
              Array.from(atob(code.slice(code.indexOf("$") + 1))).map((d) =>
                d.charCodeAt(0),
              ),
            );

            const encoded = new TextEncoder().encode(payload);

            return Promise.resolve(
              keyPromise
                .then((key) =>
                  self.crypto.subtle.verify(verifyAlgorithm, key, sig, encoded),
                )
                .then((verified) => (verified ? payload : null)),
            ).catch((_error) => {
              return null;
            });
          } catch {
            return Promise.resolve(null);
          }
        };
      }

      export function decodeAndVerifyECDSASignature(key) {
        return decodeAndVerifySignature(
          key,
          {
            name: "ECDSA",
            namedCurve: "P-384",
          },
          {
            name: "ECDSA",
            hash: { name: "SHA-384" },
          },
        );
      }

      export function signAndEncode(key, importAlgorithm, signAlgorithm) {
        if (!self.crypto || !self.crypto.subtle) {
          return (text) => Promise.resolve(text);
        }
        const keyPromise = self.crypto.subtle.importKey(
          "jwk",
          key,
          importAlgorithm,
          false,
          ["sign"],
        );

        return (payload) => {
          try {
            const encoded = new TextEncoder().encode(payload);

            return Promise.resolve(
              keyPromise
                .then((key) =>
                  self.crypto.subtle.sign(signAlgorithm, key, encoded),
                )
                .then(
                  (sig) =>
                    `${btoa(payload)}$${btoa(String.fromCharCode(...new Uint8Array(sig)))}`,
                ),
            ).catch(() => null);
          } catch {
            return Promise.resolve(payload);
          }
        };
      }

      export function signAndEncodeECDA(key) {
        return signAndEncode(
          key,
          {
            name: "ECDSA",
            namedCurve: "P-384",
          },
          {
            name: "ECDSA",
            hash: { name: "SHA-384" },
          },
        );
      }
      document.getElementById("sign").onsubmit = (e) => {
        e.preventDefault();
        const data = new FormData(e.currentTarget);
        const payload = data.get("payload").trim();
        const key = JSON.parse(data.get("key"));

        signAndEncodeECDA(key)(payload).then((r) => {
          document.getElementById("o").value = r;
        });
      };

      document.getElementById("verify").onsubmit = (e) => {
        e.preventDefault();
        const data = new FormData(e.currentTarget);
        const code = data.get("code").trim();
        const key = JSON.parse(data.get("key"));

        decodeAndVerifyECDSASignature(key)(code).then((r) => {
          document.getElementById("ov").value = r;
        });
      };

      document.getElementById("keys").onsubmit = (e) => {
        e.preventDefault();

        generateKeyPair({
          name: "ECDSA",
          namedCurve: "P-384",
        }).then((r) => {
          document.getElementById("private").value = JSON.stringify(
            r[0],
            null,
            2,
          );
          document.getElementById("public").value = JSON.stringify(
            r[1],
            null,
            2,
          );
        });
      };
    </script>
  </body>
</html>
